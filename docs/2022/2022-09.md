# 2022년 9월 TIL

## 2022.09.14

### nodejs 연습

코드캠프 백엔드 수업 커리큘럼을 참고하여 nodejs를 이용해서 간단한 함수나 템플릿 만드는 방법을 연습 중.  
실행하는 부분이 브라우저에서 nodejs로 바뀌었을 뿐인데도 굉장히 신기하다. javascript가 작동하는 원리는 동일한데도!

- **오늘의 기억할 점**  
  vercel 등으로 개발 환경을 세팅하지 않고 순수 node만으로 module 타입의 ES6 자바스크립트를 실행할 경우, import해오는 js파일에도 반드시 확장자명을 붙여줘야 한다. 그렇지 않을 경우 에러를 뱉음.

  ```js
  import {
    checkValidationEmail,
    getWelcomeTemplate,
    sendWelcomeTemplateToEmail,
  } from "./email";
  ```

  이런 식으로 쓰면

  ![error_screenshot](https://user-images.githubusercontent.com/90050960/190181398-5140a074-2482-4414-8c23-7b1ae7355665.png)

  이렇게 에러를 뱉는다.  
  귀찮아도 꼭 `.js` 붙여줘야 함..😇

  ```js
  import {
    checkValidationEmail,
    getWelcomeTemplate,
    sendWelcomeTemplateToEmail,
  } from "./email.js";
  ```

- **백엔드 공부를 갑작스레 시작한 이유**  
  간단한 api는 스스로 개발해서 개인 프로젝트 배포까지 진행하고 싶기 때문.  
  Next.js에서 제공하는 api 기능을 이용해도 좋지만, 기왕 공부하는 거 학습을 위해서라도 백엔드에 대해 좀 더 알아보고 싶었다. 새로운 언어를 배운다면 시간이 오래 걸리겠지만 javascript는 원래 사용하고 있던 언어이기도 하고.  
  간단한 프로덕트는 나 혼자서 처음부터 끝까지 개발할 수 있는 개발자가 되고 싶다. 💪

## 2022.09.12

### Typescript - 타입 가드

::: tip ref  
원티트 프리온보딩 챌린지 9월 - Typescript의 강의 내용을 일부 요약 정리 해놓은 것  
:::

1. 타입 가드란?  
   타입스크립트가 런타임 환경에서의 모든 오류를 방지해 주는 것은 아니다.  
   런타임 환경에서 실행했을때에만 확인할 수 있는 요소 정보의 경우 (dom 조작 등) type guard를 통해 미연에 방지하는 것이 좋다.

- 타입 가드의 예시

  ```ts
  const $modalClose = document.querySelector(".modalCloseButton");

  // 3. 최소한의 타입 가드
  if ($modalClose) {
    $modalClose?.addEventListener("click", () => "aaa");
  }
  ```

2. 타입 좁히기란? (Type narrowing)  
   예시를 살펴보자.
   ```ts
   const $app: HTMLElement = document.createElement("div"); // 타입추론의 효과가 거의 없는 타입
   const func: Function = function () {
     return "string";
   };
   ```
   위와 같은 스크립트의 경우 실질적으로 any script나 다를바 없다.
   연습을 통해 타입 추론을 예측하고 타입을 좁혀나가는 연습을 해야 한다.
   ```ts
   const $app: HTMLElement = document.createElement("div");
   const $app: HTMLDivElement = document.createElement("div");
   ```
3. 컴파일 vs 런타임  
   prop-types vs typescript → 무슨 차이가 있을까?  
   바로 런타임시 타입 체크 vs 컴파일시 타입 체크의 차이.  
   typescript는 컴파일시 js로 변경되기 때문에 런타임시 발생할 수 있는 타입으로 인한 오류는 checking 하지 못하는 문제가 있다.

   그렇다면 이러한 문제를 방지하기 위해서는 반드시 props-types 등의 추가 도구를 사용해야 하는가?  
   **‼️‼️‼️ 아니다!**  
   타입 가드를 잘 사용하면 런타임시 발생할 수 있는 타입 에러도 상당부분 방지할 수 있다.

   unknown을 활용한 예시를 통해 확인해보자.

   ```ts
   let num: unknown = 99;

   // 타입가드 예시 1
   // if (typeof num === 'string') {
   num.trim();
   // }

   // 타입가드 예시 2
   // (num as string).trim();

   // 스크립트 내부에 인라인 타입가드를 넣는 것도 가능 (typdof, instanceof 등 사용)
   // function func(x: unknown) {
   //   let val1: any = x;
   //   let val2: unknown = x;
   //   let val3: string = x;
   //   let val4: boolean = x;
   //   let val5: number = x;
   //   let val6: string[] = x;
   //   let val7: {} = x;
   // }
   ```

   unknown은 any와 비슷하게 사용할 수 있지만 에러를 던진다.  
    즉, 타입 가드를 유도한다.

## 2022.09.11

### Netflix-reviews 프로젝트

댓글 CRD를 완료하고 리뷰 본문과 댓글 Update 작업을 시작했다.  
그런데 본문 Update 코드를 추가하려고 보니 ReviewsWrite 페이지 스크립트가 많이 길어졌길래 가능한 코드들을 custom-hooks로 분리해서 리팩토링 하는 작업을 우선 시작했다.

```ts
const onChangeFile = async (file: ChangeEvent<HTMLInputElement>) => {
  changeFile({ file, setImages, images });
};

const handleFileBtn = () => {
  if (inputRef.current) {
    inputRef.current.click();
  }
};

const onSubmitWrite = (data: FieldValues) => {
  reviewsSubmit(data, images);
};

const onSubmitEdit = (data: FieldValues) => {
  const originImages = data.fetchBoard?.images || [""];
  reviewsEdit(data, images, originImages);
};
```

깔끔~  
작성 / 수정 / 이미지 업로드처럼 볼륨이 큰 스크립트들을 custom-hooks로 분리했고, 동일한 쿼리와 기능을 요청하는 경우에는 해당 커스텀훅을 가져다 쓸 수 있도록 인자 설정도 해두었다.

앞으로 할 일

- react-hook-form의 yupResolver schema가 수정/작성 페이지 여부에 따라 다르게 적용되도록 하기.
- 게시글 수정 후 상세페이지로 돌아왔을 때 ApolloCacheState가 변경되도록 하기
  - fetchPolicy를 변경할까 cache를 직접 수정할까 고민했는데, cache를 직접 수정하는 쪽이 더 효율적일 것이라고 판단했다.
